const axios = require('axios');
const colors = require('colors');

// Configuration
const BASE_URL = 'http://localhost:3999/api';
const JWT_TOKEN =
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2ODg3MmI0MDcyZjU1ZDhhNmYwZDVkMWUiLCJpYXQiOjE3NTQ0NTc4MzAsImV4cCI6MTc1NTA2MjYzMH0.H37rJw9VjtVhVHDRHfRS37TsJFHCrFTwIE1PRh2lhnw';
const DELAY_BETWEEN_MESSAGES = 3000; // 3 seconds between messages

// API Client setup
const apiClient = axios.create({
  baseURL: BASE_URL,
  headers: {
    Authorization: `Bearer ${JWT_TOKEN}`,
    'Content-Type': 'application/json',
  },
  timeout: 30000,
});

// Test results storage
const testResults = {
  startTime: new Date(),
  endTime: null,
  phases: {},
  logs: [],
  success: false,
  totalMessages: 0,
  errors: [],
};

// Student profile for testing
const STUDENT_PROFILE = {
  name: 'Nguy·ªÖn Minh Anh',
  age: '22',
  education: 'm·ªõi t·ªët nghi·ªáp ƒë·∫°i h·ªçc',
  major: 'K·ªπ thu·∫≠t Ph·∫ßn m·ªÅm',
  gpa: '3.5',
  targetCountry: 'Hoa K·ª≥',
  targetMajor: 'Computer Science',
  budget: '50000 USD',
  ielts: '7.0',
  dreamSchool: 'Stanford University',
  timeline: 'Fall 2025',
};

/**
 * Utility functions
 */
function log(message, type = 'info') {
  const timestamp = new Date().toISOString();
  const logEntry = {
    timestamp,
    type,
    message,
  };

  testResults.logs.push(logEntry);

  switch (type) {
    case 'success':
      console.log(`[${timestamp}] ‚úÖ ${message}`.green);
      break;
    case 'error':
      console.log(`[${timestamp}] ‚ùå ${message}`.red);
      break;
    case 'info':
      console.log(`[${timestamp}] ‚ÑπÔ∏è  ${message}`.blue);
      break;
    case 'user':
      console.log(`[${timestamp}] üë§ USER: ${message}`.yellow);
      break;
    case 'agent':
      console.log(`[${timestamp}] ü§ñ AGENT: ${message}`.cyan);
      break;
    case 'phase':
      console.log(`[${timestamp}] üìç PHASE: ${message}`.magenta);
      break;
    case 'database':
      console.log(`[${timestamp}] üíæ DATABASE: ${message}`.green);
      break;
    default:
      console.log(`[${timestamp}] ${message}`);
  }
}

function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * API Functions
 */
async function sendMessage(message) {
  try {
    log(`Sending message: "${message}"`, 'user');
    testResults.totalMessages++;

    const response = await apiClient.post('/agent/message', {
      message,
    });

    const data = response.data;
    log(`Response received - Timestamp: ${data.timestamp}`, 'success');
    log(`Agent Response: ${data.response}`, 'agent');

    return data;
  } catch (error) {
    log(`Error sending message: ${error.message}`, 'error');
    testResults.errors.push({
      message,
      error: error.message,
      timestamp: new Date(),
    });
    if (error.response) {
      log(`Error details: ${JSON.stringify(error.response.data)}`, 'error');
    }
    throw error;
  }
}

async function getSession() {
  try {
    const response = await apiClient.get('/agent/session/history');
    log(`Session retrieved: ${response.data.total} messages`, 'database');
    return response.data;
  } catch (error) {
    log(`Error getting session: ${error.message}`, 'error');
    throw error;
  }
}

async function resetSession() {
  try {
    await apiClient.delete('/agent/session');
    log('Session reset successfully', 'success');
  } catch (error) {
    log(`Error resetting session: ${error.message}`, 'info');
    // It's okay if reset fails, maybe there's no session to reset
  }
}

async function healthCheck() {
  try {
    const response = await apiClient.get('/agent/health');
    log(`Health check passed: ${response.data.status}`, 'success');
    return response.data;
  } catch (error) {
    log(`Health check failed: ${error.message}`, 'error');
    throw error;
  }
}

/**
 * Test Phases
 */

// Phase 1: COLLECT_INFO - Thu th·∫≠p th√¥ng tin c∆° b·∫£n
async function testPhaseCollectInfo() {
  log('\nüöÄ PHASE 1: COLLECT_INFO - Thu th·∫≠p th√¥ng tin c∆° b·∫£n', 'phase');

  const phaseResults = {
    phase: 'collect_info',
    messages: [],
    startTime: new Date(),
  };

  // Tin nh·∫Øn gi·ªõi thi·ªáu ƒë·∫ßu ti√™n
  let response = await sendMessage('Xin ch√†o! T√¥i mu·ªën t∆∞ v·∫•n v·ªÅ du h·ªçc');
  phaseResults.messages.push({
    user: 'Xin ch√†o! T√¥i mu·ªën t∆∞ v·∫•n v·ªÅ du h·ªçc',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  // Cung c·∫•p th√¥ng tin c√° nh√¢n t·ª´ng b∆∞·ªõc
  response = await sendMessage(
    `T√™n t√¥i l√† ${STUDENT_PROFILE.name}, ${STUDENT_PROFILE.age} tu·ªïi`,
  );
  phaseResults.messages.push({
    user: `T√™n t√¥i l√† ${STUDENT_PROFILE.name}, ${STUDENT_PROFILE.age} tu·ªïi`,
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  response = await sendMessage(
    `T√¥i ${STUDENT_PROFILE.education}, chuy√™n ng√†nh ${STUDENT_PROFILE.major}, GPA ${STUDENT_PROFILE.gpa}`,
  );
  phaseResults.messages.push({
    user: `T√¥i ${STUDENT_PROFILE.education}, chuy√™n ng√†nh ${STUDENT_PROFILE.major}, GPA ${STUDENT_PROFILE.gpa}`,
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  response = await sendMessage(
    `T√¥i mu·ªën ƒëi du h·ªçc ${STUDENT_PROFILE.targetCountry}, ng√¢n s√°ch kho·∫£ng ${STUDENT_PROFILE.budget}`,
  );
  phaseResults.messages.push({
    user: `T√¥i mu·ªën ƒëi du h·ªçc ${STUDENT_PROFILE.targetCountry}, ng√¢n s√°ch kho·∫£ng ${STUDENT_PROFILE.budget}`,
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  response = await sendMessage(
    `T√¥i c√≥ IELTS ${STUDENT_PROFILE.ielts}, mu·ªën h·ªçc ${STUDENT_PROFILE.targetMajor}`,
  );
  phaseResults.messages.push({
    user: `T√¥i c√≥ IELTS ${STUDENT_PROFILE.ielts}, mu·ªën h·ªçc ${STUDENT_PROFILE.targetMajor}`,
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  phaseResults.endTime = new Date();
  testResults.phases.collect_info = phaseResults;

  log('‚úÖ Phase COLLECT_INFO completed', 'success');
  return phaseResults;
}

// Phase 2: SELECT_SCHOOL - G·ª£i √Ω tr∆∞·ªùng h·ªçc
async function testPhaseSelectSchool() {
  log('\nüéì PHASE 2: SELECT_SCHOOL - G·ª£i √Ω tr∆∞·ªùng h·ªçc', 'phase');

  const phaseResults = {
    phase: 'select_school',
    messages: [],
    startTime: new Date(),
  };

  // Y√™u c·∫ßu g·ª£i √Ω tr∆∞·ªùng h·ªçc
  let response = await sendMessage(
    'B·∫°n c√≥ th·ªÉ g·ª£i √Ω cho t√¥i m·ªôt s·ªë tr∆∞·ªùng ƒë·∫°i h·ªçc ph√π h·ª£p kh√¥ng?',
  );
  phaseResults.messages.push({
    user: 'B·∫°n c√≥ th·ªÉ g·ª£i √Ω cho t√¥i m·ªôt s·ªë tr∆∞·ªùng ƒë·∫°i h·ªçc ph√π h·ª£p kh√¥ng?',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  // H·ªèi th√™m v·ªÅ c√°c tr∆∞·ªùng c·ª• th·ªÉ
  response = await sendMessage(
    'T√¥i quan t√¢m ƒë·∫øn Stanford University. B·∫°n c√≥ th·ªÉ cho t√¥i bi·∫øt th√™m th√¥ng tin kh√¥ng?',
  );
  phaseResults.messages.push({
    user: 'T√¥i quan t√¢m ƒë·∫øn Stanford University. B·∫°n c√≥ th·ªÉ cho t√¥i bi·∫øt th√™m th√¥ng tin kh√¥ng?',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  // So s√°nh c√°c tr∆∞·ªùng
  response = await sendMessage(
    'MIT v√† Stanford kh√°c nhau nh∆∞ th·∫ø n√†o? Tr∆∞·ªùng n√†o ph√π h·ª£p v·ªõi t√¥i h∆°n?',
  );
  phaseResults.messages.push({
    user: 'MIT v√† Stanford kh√°c nhau nh∆∞ th·∫ø n√†o? Tr∆∞·ªùng n√†o ph√π h·ª£p v·ªõi t√¥i h∆°n?',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  // Quy·∫øt ƒë·ªãnh ch·ªçn tr∆∞·ªùng
  response = await sendMessage(
    `T√¥i quy·∫øt ƒë·ªãnh ch·ªçn ${STUDENT_PROFILE.dreamSchool} ƒë·ªÉ apply. B√¢y gi·ªù t√¥i c·∫ßn l√†m g√¨?`,
  );
  phaseResults.messages.push({
    user: `T√¥i quy·∫øt ƒë·ªãnh ch·ªçn ${STUDENT_PROFILE.dreamSchool} ƒë·ªÉ apply. B√¢y gi·ªù t√¥i c·∫ßn l√†m g√¨?`,
    agent: response.response,
    timestamp: response.timestamp,
    selectedSchool: STUDENT_PROFILE.dreamSchool,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  phaseResults.endTime = new Date();
  testResults.phases.select_school = phaseResults;

  log('‚úÖ Phase SELECT_SCHOOL completed', 'success');
  return phaseResults;
}

// Phase 3: LEGAL_CHECKLIST - Qu·∫£n l√Ω gi·∫•y t·ªù ph√°p l√Ω
async function testPhaseLegalChecklist() {
  log('\nüìã PHASE 3: LEGAL_CHECKLIST - Qu·∫£n l√Ω gi·∫•y t·ªù ph√°p l√Ω', 'phase');

  const phaseResults = {
    phase: 'legal_checklist',
    messages: [],
    startTime: new Date(),
  };

  // H·ªèi v·ªÅ gi·∫•y t·ªù c·∫ßn chu·∫©n b·ªã
  let response = await sendMessage(
    'T√¥i c·∫ßn chu·∫©n b·ªã nh·ªØng gi·∫•y t·ªù g√¨ ƒë·ªÉ du h·ªçc M·ªπ?',
  );
  phaseResults.messages.push({
    user: 'T√¥i c·∫ßn chu·∫©n b·ªã nh·ªØng gi·∫•y t·ªù g√¨ ƒë·ªÉ du h·ªçc M·ªπ?',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  // Y√™u c·∫ßu t·∫°o danh s√°ch chi ti·∫øt
  response = await sendMessage(
    'H√£y t·∫°o cho t√¥i danh s√°ch chi ti·∫øt c√°c gi·∫•y t·ªù c·∫ßn chu·∫©n b·ªã cho Stanford University',
  );
  phaseResults.messages.push({
    user: 'H√£y t·∫°o cho t√¥i danh s√°ch chi ti·∫øt c√°c gi·∫•y t·ªù c·∫ßn chu·∫©n b·ªã cho Stanford University',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  // H·ªèi v·ªÅ quy tr√¨nh visa
  response = await sendMessage(
    'Quy tr√¨nh xin visa F-1 nh∆∞ th·∫ø n√†o? T√¥i c·∫ßn l√†m g√¨ tr∆∞·ªõc ti√™n?',
  );
  phaseResults.messages.push({
    user: 'Quy tr√¨nh xin visa F-1 nh∆∞ th·∫ø n√†o? T√¥i c·∫ßn l√†m g√¨ tr∆∞·ªõc ti√™n?',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  // B√°o c√°o ti·∫øn ƒë·ªô chu·∫©n b·ªã
  response = await sendMessage(
    'T√¥i ƒë√£ c√≥ h·ªô chi·∫øu v√† b·∫±ng t·ªët nghi·ªáp ƒë·∫°i h·ªçc. C√≤n thi·∫øu g√¨ n·ªØa?',
  );
  phaseResults.messages.push({
    user: 'T√¥i ƒë√£ c√≥ h·ªô chi·∫øu v√† b·∫±ng t·ªët nghi·ªáp ƒë·∫°i h·ªçc. C√≤n thi·∫øu g√¨ n·ªØa?',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  phaseResults.endTime = new Date();
  testResults.phases.legal_checklist = phaseResults;

  log('‚úÖ Phase LEGAL_CHECKLIST completed', 'success');
  return phaseResults;
}

// Phase 4: LIFE_PLANNING - T∆∞ v·∫•n sinh s·ªëng
async function testPhaseLifePlanning() {
  log('\nüè† PHASE 4: LIFE_PLANNING - T∆∞ v·∫•n sinh s·ªëng', 'phase');

  const phaseResults = {
    phase: 'life_planning',
    messages: [],
    startTime: new Date(),
  };

  // H·ªèi v·ªÅ chi ph√≠ sinh ho·∫°t
  let response = await sendMessage(
    'Chi ph√≠ sinh ho·∫°t ·ªü Stanford kho·∫£ng bao nhi√™u m·ªôt th√°ng?',
  );
  phaseResults.messages.push({
    user: 'Chi ph√≠ sinh ho·∫°t ·ªü Stanford kho·∫£ng bao nhi√™u m·ªôt th√°ng?',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  // H·ªèi v·ªÅ ch·ªó ·ªü
  response = await sendMessage(
    'T√¥i n√™n ·ªü k√Ω t√∫c x√° hay thu√™ nh√† ri√™ng? ∆Øu nh∆∞·ª£c ƒëi·ªÉm nh∆∞ th·∫ø n√†o?',
  );
  phaseResults.messages.push({
    user: 'T√¥i n√™n ·ªü k√Ω t√∫c x√° hay thu√™ nh√† ri√™ng? ∆Øu nh∆∞·ª£c ƒëi·ªÉm nh∆∞ th·∫ø n√†o?',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  // H·ªèi v·ªÅ l√†m th√™m
  response = await sendMessage(
    'Sinh vi√™n F-1 c√≥ ƒë∆∞·ª£c ph√©p l√†m th√™m kh√¥ng? T√¥i c√≥ th·ªÉ ki·∫øm ti·ªÅn ƒë·ªÉ trang tr·∫£i chi ph√≠ kh√¥ng?',
  );
  phaseResults.messages.push({
    user: 'Sinh vi√™n F-1 c√≥ ƒë∆∞·ª£c ph√©p l√†m th√™m kh√¥ng? T√¥i c√≥ th·ªÉ ki·∫øm ti·ªÅn ƒë·ªÉ trang tr·∫£i chi ph√≠ kh√¥ng?',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  // H·ªèi v·ªÅ k·ªπ nƒÉng s·ªëng
  response = await sendMessage(
    'T√¥i c·∫ßn chu·∫©n b·ªã nh·ªØng k·ªπ nƒÉng g√¨ ƒë·ªÉ s·ªëng ƒë·ªôc l·∫≠p ·ªü M·ªπ?',
  );
  phaseResults.messages.push({
    user: 'T√¥i c·∫ßn chu·∫©n b·ªã nh·ªØng k·ªπ nƒÉng g√¨ ƒë·ªÉ s·ªëng ƒë·ªôc l·∫≠p ·ªü M·ªπ?',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  phaseResults.endTime = new Date();
  testResults.phases.life_planning = phaseResults;

  log('‚úÖ Phase LIFE_PLANNING completed', 'success');
  return phaseResults;
}

// Phase 5: PROGRESS_TRACKING - Theo d√µi ti·∫øn ƒë·ªô
async function testPhaseProgressTracking() {
  log('\nüìä PHASE 5: PROGRESS_TRACKING - Theo d√µi ti·∫øn ƒë·ªô', 'phase');

  const phaseResults = {
    phase: 'progress_tracking',
    messages: [],
    startTime: new Date(),
  };

  // Quay l·∫°i h·ªèi v·ªÅ gi·∫•y t·ªù ƒë·ªÉ trigger chuy·ªÉn phase
  let response = await sendMessage(
    'T√¥i ƒë√£ ho√†n th√†nh ƒë∆°n xin visa F-1 v√† ƒë√£ n·ªôp. B√¢y gi·ªù t√¥i c·∫ßn l√†m g√¨ ti·∫øp theo?',
  );
  phaseResults.messages.push({
    user: 'T√¥i ƒë√£ ho√†n th√†nh ƒë∆°n xin visa F-1 v√† ƒë√£ n·ªôp. B√¢y gi·ªù t√¥i c·∫ßn l√†m g√¨ ti·∫øp theo?',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  // B√°o c√°o ti·∫øn ƒë·ªô chu·∫©n b·ªã
  response = await sendMessage(
    'T√¥i ƒë√£ l√†m xong c√°c gi·∫•y t·ªù: h·ªô chi·∫øu, b·∫±ng t·ªët nghi·ªáp, DS-160, ƒë√£ ƒë√≥ng ph√≠ SEVIS. C√≤n g√¨ n·ªØa kh√¥ng?',
  );
  phaseResults.messages.push({
    user: 'T√¥i ƒë√£ l√†m xong c√°c gi·∫•y t·ªù: h·ªô chi·∫øu, b·∫±ng t·ªët nghi·ªáp, DS-160, ƒë√£ ƒë√≥ng ph√≠ SEVIS. C√≤n g√¨ n·ªØa kh√¥ng?',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  // H·ªèi v·ªÅ timeline
  response = await sendMessage(
    'Timeline chu·∫©n b·ªã cho k·ª≥ Fall 2025 nh∆∞ th·∫ø n√†o? T√¥i c√≥ ƒëang ƒë√∫ng ti·∫øn ƒë·ªô kh√¥ng?',
  );
  phaseResults.messages.push({
    user: 'Timeline chu·∫©n b·ªã cho k·ª≥ Fall 2025 nh∆∞ th·∫ø n√†o? T√¥i c√≥ ƒëang ƒë√∫ng ti·∫øn ƒë·ªô kh√¥ng?',
    agent: response.response,
    timestamp: response.timestamp,
  });
  await delay(DELAY_BETWEEN_MESSAGES);

  phaseResults.endTime = new Date();
  testResults.phases.progress_tracking = phaseResults;

  log('‚úÖ Phase PROGRESS_TRACKING completed', 'success');
  return phaseResults;
}

// Test phase transitions
async function testPhaseTransitions() {
  log('\nüîÑ TESTING PHASE TRANSITIONS', 'phase');

  // Test chuy·ªÉn t·ª´ life_planning v·ªÅ legal_checklist
  let response = await sendMessage(
    'T√¥i c·∫ßn xem l·∫°i danh s√°ch gi·∫•y t·ªù visa m·ªôt l·∫ßn n·ªØa',
  );
  await delay(DELAY_BETWEEN_MESSAGES);

  // Test chuy·ªÉn t·ª´ legal v·ªÅ life_planning
  response = await sendMessage('Chi ph√≠ ƒÉn u·ªëng ·ªü Stanford nh∆∞ th·∫ø n√†o?');
  await delay(DELAY_BETWEEN_MESSAGES);

  // Test chuy·ªÉn v·ªÅ select_school
  response = await sendMessage(
    'T√¥i ƒëang ph√¢n v√¢n gi·ªØa Stanford v√† MIT. B·∫°n c√≥ th·ªÉ t∆∞ v·∫•n l·∫°i kh√¥ng?',
  );
  await delay(DELAY_BETWEEN_MESSAGES);

  log('‚úÖ Phase transitions tested', 'success');
}

/**
 * Main test function
 */
async function runFullFlowTest() {
  try {
    log('üöÄ Starting Full Flow Test for Agent /api/agent/message', 'info');
    log(
      `üìã Student Profile: ${STUDENT_PROFILE.name}, ${STUDENT_PROFILE.age} tu·ªïi, ${STUDENT_PROFILE.education}`,
      'info',
    );
    log(
      `üéØ Target: ${STUDENT_PROFILE.targetMajor} t·∫°i ${STUDENT_PROFILE.dreamSchool}, ${STUDENT_PROFILE.targetCountry}`,
      'info',
    );
    log(`üí∞ Budget: ${STUDENT_PROFILE.budget}`, 'info');

    // Health check
    await healthCheck();

    // Reset session ƒë·ªÉ b·∫Øt ƒë·∫ßu clean
    await resetSession();
    await delay(1000);

    // Run all phases in sequence
    await testPhaseCollectInfo();
    await testPhaseSelectSchool();
    await testPhaseLegalChecklist();
    await testPhaseLifePlanning();
    await testPhaseProgressTracking();

    // Test phase transitions
    await testPhaseTransitions();

    // Final session check
    const finalSession = await getSession();
    log(
      `üìä Final session has ${finalSession.total} total messages`,
      'database',
    );

    testResults.success = true;
    testResults.endTime = new Date();

    log('\nüéâ FULL FLOW TEST COMPLETED SUCCESSFULLY!', 'success');
  } catch (error) {
    log(`‚ùå Test failed: ${error.message}`, 'error');
    testResults.success = false;
    testResults.endTime = new Date();
    testResults.errors.push({
      phase: 'main',
      error: error.message,
      timestamp: new Date(),
    });
  }
}

/**
 * Generate test report
 */
function generateTestReport() {
  const duration = testResults.endTime - testResults.startTime;
  const report = {
    ...testResults,
    duration: Math.round(duration / 1000), // seconds
    student_profile: STUDENT_PROFILE,
  };

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const filename = `test-result/agent-full-flow-test-${timestamp}.json`;

  require('fs').writeFileSync(filename, JSON.stringify(report, null, 2));

  console.log('\nüìÑ TEST REPORT:'.blue);
  console.log(`Duration: ${report.duration} seconds`.green);
  console.log(`Total Messages: ${report.totalMessages}`.green);
  console.log(`Success: ${report.success ? '‚úÖ' : '‚ùå'}`.green);
  console.log(`Errors: ${report.errors.length}`.yellow);
  console.log(`Report saved to: ${filename}`.blue);

  if (report.phases) {
    console.log('\nüìä PHASE SUMMARY:'.blue);
    Object.keys(report.phases).forEach((phase) => {
      const phaseData = report.phases[phase];
      const phaseDuration = phaseData.endTime - phaseData.startTime;
      console.log(
        `  ${phase}: ${phaseData.messages.length} messages, ${Math.round(phaseDuration / 1000)}s`
          .cyan,
      );
    });
  }

  return report;
}

/**
 * Run the test
 */
if (require.main === module) {
  runFullFlowTest()
    .then(() => {
      generateTestReport();
      process.exit(0);
    })
    .catch((error) => {
      console.error('Fatal error:', error);
      generateTestReport();
      process.exit(1);
    });
}

module.exports = {
  runFullFlowTest,
  testResults,
  STUDENT_PROFILE,
};
